From 427201bacb8721879182b65ec58a22df403998a2 Mon Sep 17 00:00:00 2001
From: GarfieldHan <2652609017@qq.com>
Date: Mon, 29 Nov 2021 00:04:53 +0800
Subject: [PATCH] twrpinstall: Switch to ZipEntry64

The libziparchive TWRP using was outdated, not supported a zip
size more than 4 GiB. With the development of technologies,
Obviously it was not enough for ROM packages, like Xiaomi's
MIUI for Vitrual A/B devices (for example Redmi K40 [alioth])
is more than 4 GiB and TWRP couldn't handle it properly.
Since we have updated libziparchive to latest version, we could
switch ZipEntry to ZipEntry64 so that TWRP can support a ROM
package if its size more than 4 GiB.

Co-authored-by: sekaiacg <sekaiacg@gmail.com>
Signed-off-by: GarfieldHan <2652609017@qq.com>
Change-Id: Iee811554bb08e02bf2bd8e9057511f36caefdc9d
---

diff --git a/twrpinstall/ZipUtil.cpp b/twrpinstall/ZipUtil.cpp
index f8134bc..f073a22 100755
--- a/twrpinstall/ZipUtil.cpp
+++ b/twrpinstall/ZipUtil.cpp
@@ -63,7 +63,7 @@
     }
 
     std::unique_ptr<void, decltype(&EndIteration)> guard(cookie, EndIteration);
-    ZipEntry entry;
+    ZipEntry64 entry;
     ZipString name;
     int extractCount = 0;
     while (Next(cookie, &entry, &name) == 0) {
diff --git a/twrpinstall/install.cpp b/twrpinstall/install.cpp
index 5295405..d270d26 100755
--- a/twrpinstall/install.cpp
+++ b/twrpinstall/install.cpp
@@ -72,7 +72,7 @@
 
   static constexpr const char* METADATA_PATH = "META-INF/com/android/metadata";
   std::string path(METADATA_PATH);
-  ZipEntry entry;
+  ZipEntry64 entry;
   if (FindEntry(zip, path, &entry) != 0) {
     LOG(ERROR) << "Failed to find " << METADATA_PATH;
     return false;
@@ -235,7 +235,7 @@
   // in the zip file.
   static constexpr const char* AB_OTA_PAYLOAD_PROPERTIES = "payload_properties.txt";
   std::string property_name(AB_OTA_PAYLOAD_PROPERTIES);
-  ZipEntry properties_entry;
+  ZipEntry64 properties_entry;
   if (FindEntry(zip, property_name, &properties_entry) != 0) {
     LOG(ERROR) << "Failed to find " << AB_OTA_PAYLOAD_PROPERTIES;
     return INSTALL_CORRUPT;
@@ -251,7 +251,7 @@
 
   static constexpr const char* AB_OTA_PAYLOAD = "payload.bin";
   std::string payload_name(AB_OTA_PAYLOAD);
-  ZipEntry payload_entry;
+  ZipEntry64 payload_entry;
   if (FindEntry(zip, payload_name, &payload_entry) != 0) {
     LOG(ERROR) << "Failed to find " << AB_OTA_PAYLOAD;
     return INSTALL_CORRUPT;
@@ -273,7 +273,7 @@
 
   // In non-A/B updates we extract the update binary from the package.
   std::string binary_name(UPDATE_BINARY_NAME);
-  ZipEntry binary_entry;
+  ZipEntry64 binary_entry;
   if (FindEntry(zip, binary_name, &binary_entry) != 0) {
     LOG(ERROR) << "Failed to find update binary " << UPDATE_BINARY_NAME;
     return INSTALL_CORRUPT;
@@ -390,7 +390,7 @@
 
   is_ab = false;
   std::string binary_name(UPDATE_BINARY_NAME);
-  ZipEntry binary_entry;
+  ZipEntry64 binary_entry;
   if (FindEntry(zip, binary_name, &binary_entry) != 0) {
     LOG(ERROR) << "Failed to find update binary " << UPDATE_BINARY_NAME;
     is_ab = true;
@@ -521,7 +521,7 @@
 
 //   static constexpr const char* COMPATIBILITY_ZIP_ENTRY = "compatibility.zip";
 //   ZipString compatibility_entry_name(COMPATIBILITY_ZIP_ENTRY);
-//   ZipEntry compatibility_entry;
+//   ZipEntry64 compatibility_entry;
 //   if (FindEntry(package_zip, compatibility_entry_name, &compatibility_entry) != 0) {
 //     LOG(INFO) << "Package doesn't contain " << COMPATIBILITY_ZIP_ENTRY << " entry";
 //     return true;
@@ -555,7 +555,7 @@
 //   std::unique_ptr<void, decltype(&EndIteration)> guard(cookie, EndIteration);
 
 //   std::vector<std::string> compatibility_info;
-//   ZipEntry info_entry;
+//   ZipEntry64 info_entry;
 //   ZipString info_name;
 //   while (Next(cookie, &info_entry, &info_name) == 0) {
 //     std::string content(info_entry.uncompressed_length, '\0');
diff --git a/twrpinstall/installcommand.cpp b/twrpinstall/installcommand.cpp
index 2d2bc61..07db5c1 100755
--- a/twrpinstall/installcommand.cpp
+++ b/twrpinstall/installcommand.cpp
@@ -55,7 +55,7 @@
 
 bool read_metadata_from_package(ZipArchiveHandle zip, std::string* meta_data) {
     std::string binary_name(METADATA_PATH);
-    ZipEntry binary_entry;
+    ZipEntry64 binary_entry;
     if (FindEntry(zip, binary_name, &binary_entry) == 0) {
         long size = binary_entry.uncompressed_length;
         if (size <= 0)
@@ -202,7 +202,7 @@
     // the RAW payload offset in the zip file.
     // if (!Zip->EntryExists(AB_OTA_PAYLOAD_PROPERTIES)) {
 	std::string binary_name(AB_OTA_PAYLOAD_PROPERTIES);
-    ZipEntry binary_entry;
+    ZipEntry64 binary_entry;
     if (FindEntry(Zip, binary_name, &binary_entry) != 0) {
         printf("Can't find %s\n", AB_OTA_PAYLOAD_PROPERTIES);
         return INSTALL_CORRUPT;
@@ -218,7 +218,7 @@
     }
 
     std::string ab_ota_payload(AB_OTA_PAYLOAD);
-    ZipEntry ab_ota_payload_entry;
+    ZipEntry64 ab_ota_payload_entry;
     if (FindEntry(Zip, ab_ota_payload, &ab_ota_payload_entry) != 0) {
         printf("Can't find %s\n", AB_OTA_PAYLOAD);
         return INSTALL_CORRUPT;
@@ -279,7 +279,7 @@
 
   static constexpr const char* COMPATIBILITY_ZIP_ENTRY = "compatibility.zip";
   std::string compatibility_entry_name(COMPATIBILITY_ZIP_ENTRY);
-  ZipEntry compatibility_entry;
+  ZipEntry64 compatibility_entry;
   if (FindEntry(zw, compatibility_entry_name, &compatibility_entry) != 0) {
     printf("Package doesn't contain %s entry\n", COMPATIBILITY_ZIP_ENTRY);
     return true;
@@ -313,7 +313,7 @@
   std::unique_ptr<void, decltype(&EndIteration)> guard(cookie, EndIteration);
 
   std::vector<std::string> compatibility_info;
-  ZipEntry info_entry;
+  ZipEntry64 info_entry;
   std::string info_name;
   while (Next(cookie, &info_entry, &info_name) == 0) {
     std::string content(info_entry.uncompressed_length, '\0');
diff --git a/twrpinstall/twinstall.cpp b/twrpinstall/twinstall.cpp
index 849b3ad..46461f4 100755
--- a/twrpinstall/twinstall.cpp
+++ b/twrpinstall/twinstall.cpp
@@ -75,7 +75,7 @@
 	return INSTALL_CORRUPT;
 #else
 	std::string binary_name("ui.xml");
-	ZipEntry binary_entry;
+	ZipEntry64 binary_entry;
 	if (FindEntry(Zip, binary_name, &binary_entry) != 0) {
 		CloseArchive(Zip);
 		return INSTALL_CORRUPT;
@@ -108,7 +108,7 @@
 	std::vector<string>::iterator arch;
 	std::string base_name = UPDATE_BINARY_NAME;
 	base_name += "-";
-	ZipEntry binary_entry;
+	ZipEntry64 binary_entry;
 	std::string update_binary_string(UPDATE_BINARY_NAME);
 	if (FindEntry(Zip, update_binary_string, &binary_entry) != 0) {
 		for (arch = split.begin(); arch != split.end(); arch++) {
@@ -136,7 +136,7 @@
 
 	// If exists, extract file_contexts from the zip file
 	std::string file_contexts("file_contexts");
-	ZipEntry file_contexts_entry;
+	ZipEntry64 file_contexts_entry;
 	if (FindEntry(Zip, file_contexts, &file_contexts_entry) != 0) {
 		LOGINFO("Zip does not contain SELinux file_contexts file in its root.\n");
 	} else {
@@ -313,7 +313,7 @@
 	time(&start);
 
 	std::string update_binary_name(UPDATE_BINARY_NAME);
-	ZipEntry update_binary_entry;
+	ZipEntry64 update_binary_entry;
 	if (FindEntry(Zip, update_binary_name, &update_binary_entry) == 0) {
 		LOGINFO("Update binary zip\n");
 		// Additionally verify the compatibility of the package.
@@ -328,7 +328,7 @@
 		}
 	} else {
 		std::string ab_binary_name(AB_OTA);
-		ZipEntry ab_binary_entry;
+		ZipEntry64 ab_binary_entry;
 		if (FindEntry(Zip, ab_binary_name, &ab_binary_entry) == 0) {
 			LOGINFO("AB zip\n");
 			gui_msg(Msg(msg::kHighlight, "flash_ab_inactive=Flashing A/B zip to inactive slot: {1}")(PartitionManager.Get_Active_Slot_Display()=="A"?"B":"A"));
@@ -358,7 +358,7 @@
 			}
 		} else {
 			std::string binary_name("ui.xml");
-			ZipEntry binary_entry;
+			ZipEntry64 binary_entry;
 			if (FindEntry(Zip, binary_name, &binary_entry) != 0) {
 				LOGINFO("TWRP theme zip\n");
 				ret_val = Install_Theme(path, Zip);
diff --git a/twrpinstall/verifier.cpp b/twrpinstall/verifier.cpp
index 1fa8279..02ec987 100755
--- a/twrpinstall/verifier.cpp
+++ b/twrpinstall/verifier.cpp
@@ -328,7 +328,7 @@
   std::vector<Certificate> result;
 
   std::string_view name;
-  ZipEntry entry;
+  ZipEntry64 entry;
   while ((iter_status = Next(cookie, &entry, &name)) == 0) {
     std::vector<uint8_t> pem_content(entry.uncompressed_length);
     if (int32_t extract_status =
